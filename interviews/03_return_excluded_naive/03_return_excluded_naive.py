def task_1_return_excluded_naive(a, b):
    """
    Задача 1. Даны два списка, вернуть элементы, которые есть в 1-ом списке, но нет во 2-ом.
    Оценить эффективность своего решения.
    :param a:
    :param b:
    :return:
    """
    # Наивное решение
    c = []

    for i in a:
        for j in b:
            if i == j:
                c.append(i)
                # Двойной цикл, это O(n^2)

    for i in c:
        if i in a:
            a.remove(i)  # Удаление элемента из массива - O(n)
            # Плюс проход по циклу, итого O(n^2)

    # Причем, второй двойной цикл можно заменить, на что-то более простое, но основа здесь
    # - это поэлементное сравнение двух множеств. Это неэффективно.

    # Итого, сложность - O(n^2)
    return a


def task_1_return_excluded(a, b):
    """
    Задача 1. Даны два списка, вернуть элементы, которые есть в 1-ом списке, но нет во 2-ом.
    Оценить эффективность своего решения.
    :param a:
    :param b:
    :return:
    """

    # Преобразуем массив B в set, это позволит проверять вхождение элементов A in B за О(1)
    # На преобразование потратим 1 проход -  О(n)
    b_set = set(b)
    res = []

    # Дальше пройдем по всем элементам списка A, и проверим не_вхождение в B, если не входит, добавим в результат.
    for elem in a:
        if elem not in b:
            res.append(elem)  # Это динамический массив, амортизированное время вставки будет О(1)

    # Таким образом, ассимптотическая сложность будет O(n) (два прохода)
    return res
